# Mock Exam 1

You don't get what you wish for. You get what you work for.

– Daniel Milstein

I am experienced enough to do this. I am knowledgeable enough to do this. I am prepared enough to do this. I am mature enough to do this. I am brave enough to do this.

1. Create a Pod **mc-pod** in the **mc-namespace** namespace with three containers. The first container should be named **mc-pod-1**, run the **nginx:1-alpine** image, and set an environment variable **NODE_NAME** to the node name. The second container should be named **mc-pod-2**, run the **busybox:1** image, and continuously log the output of the date command to the file ``` /var/log/shared/date.log ``` every second. The third container should have the name **mc-pod-3**, run the image **busybox:1**, and print the contents of the **date.log** file generated by the second container to stdout. Use a shared, non-persistent volume.

**Solution**

You need to create a Pod named mc-pod in the mc-namespace namespace with three containers:

1.1 First container (mc-pod-1):

Uses the image **nginx:1-alpine**.
Sets an environment variable **NODE_NAME** to the node name where the pod is running.
This is done using the fieldRef:

```yaml
env:
- name: NODE_NAME
  valueFrom:
    fieldRef:
      fieldPath: spec.nodeName
```

1.2 Second container (mc-pod-2):

Uses the image **busybox:1**.
Runs a command that writes the output of the date command to ``` /var/log/shared/date.log ``` every second in an infinite loop.
Example command:

```yaml
- name: mc-pod-2
  image: busybox:1
  command: ["sh", "-c", "while true; do date >> /var/log/shared/date.log; sleep 1; done"]
  volumeMounts:
  - name: shared-logs
    mountPath: /var/log/shared
```

Mounts a shared volume at /var/log/shared.

1.3 Third container (mc-pod-3):

Uses the image **busybox:1**.
Reads and prints the contents of ```/var/log/shared/date.log ``` to stdout.
Example command:

```bash
command: ["sh", "-c", "tail -f /var/log/shared/date.log"]
```

Also mounts the same shared volume at ``` /var/log/shared ```.

All three containers share a non-persistent (emptyDir) volume mounted at ``` /var/log/shared ```.


Yaml manifest:

```yaml
# 01_mc-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mc-pod
  namespace: mc-namespace
spec:
  containers:
  - name: mc-pod-1
    image: nginx:1-alpine
    env:
    - name: NODE_NAME
      valueFrom:
        fieldRef:
          fieldPath: spec.nodeName
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/shared
  - name: mc-pod-2
    image: busybox:1
    command: ["sh", "-c", "while true; do date >> /var/log/shared/date.log; sleep 1; done"]
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/shared
  - name: mc-pod-3
    image: busybox:1
    command: ["sh", "-c", "tail -f /var/log/shared/date.log"]
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/shared 
  volumes:
  - name: shared-logs
    emptyDir: {}
```

```bash
# -l line numbers activated.
# Alternatively, while the file is open, you can press ALT + C to display the current line number at the bottom of the editor. 
nano -l mc-pod.yaml

k apply --validate=true -f mc-pod.yaml
```

Command to access a specific container
To run an interactive shell in one of the containers, use:

```sh
kubectl exec -it mc-pod -n mc-namespace -c mc-pod-1 -- sh
```

You can change mc-pod-1 to mc-pod-2 or mc-pod-3 depending on the container you want to inspect.

View the contents of /var/log/shared
Once inside the container, you can list the files:

```sh
ls -l /var/log/shared
```

And if you want to see the contents of the file generated by mc-pod-2:

```sh
cat /var/log/shared/date.log
```
Or follow it in real time (although mc-pod-3 already does that):

```sh
tail -f /var/log/shared/date.log
```

2. This question needs to be solved on node node01. To access the node using SSH, use the credentials below:

```bash
username: bob
password: caleston123
```

As an administrator, you need to prepare **node01** to install kubernetes. One of the steps is installing a container runtime. Install the **cri-docker_0.3.16.3-0.debian.deb** package located in /root and ensure that the **cri-docker** service is running and enabled to start on boot.

**Solution**

2.1 SSH into node01
Use the provided credentials:

```sh
username: bob
password: caleston123
```
2.2 Switch to root user (if needed):

```sh
sudo -i
```

2.3 Install the cri-docker package:

```sh
dpkg -i /root/cri-docker_0.3.16.3-0.debian.deb
```

2.4 Start the cri-docker service:

```sh
systemctl start cri-docker
```

2.5 Enable the cri-docker service to start on boot:

```sh
systemctl enable cri-docker
```

2.6 Verify the service is running:

```sh
systemctl status cri-docker
```

3. On controlplane node, identify all CRDs related to VerticalPodAutoscaler and save their names into the file /``` root/vpa-crds.txt ```.

**Solution**

3.1 List all CRDs and filter those related to VerticalPodAutoscaler:

Use the following command to list all CRDs and filter for those containing "verticalpodautoscaler" (case-insensitive):

```sh
kubectl get crds | grep -i verticalpodautoscaler
```

3.2 Extract only the CRD names and save them to the file:

You can use awk to get just the first column (the CRD name):

```sh
kubectl get crds | grep -i verticalpodautoscaler | awk '{print $1}' > /root/vpa-crds.txt
```

**grep -i verticalpodautoscaler**

Filters the above output to show only lines containing the text verticalpodautoscaler, regardless of case (-i is for ignore case).

**awk '{print $1}'**

Of each filtered line, awk prints only the first column (field), which is usually the CRD name.


3.3 Verify the contents of the file:

```sh
cat /root/vpa-crds.txt
```

4. Create a service **messaging-service** to expose the messaging application within the cluster on port 6379.



5. Create a deployment named hr-web-app using the image **kodekloud/webapp-color** with 2 replicas.

6. A new application orange is deployed. There is something wrong with it. Identify and fix the issue.

7. Expose the hr-web-app created in the previous task as a service named **hr-web-app-service**, accessible on port **30082** on the nodes of the cluster.

The web application listens on port **8080**.

8. Create a Persistent Volume with the given specification: -

- Volume name: pv-analytics
- Storage: 100Mi
- Access mode: ReadWriteMany
- Host path: /pv/data-analytics

9. Create a Horizontal Pod Autoscaler (HPA) with name **webapp-hpa** for the deployment named **kkapp-deploy** in the default namespace with the **webapp-hpa.yaml** file located under the root folder.
Ensure that the HPA scales the deployment based on CPU utilization, maintaining an average CPU usage of 50% across all pods.
Configure the HPA to cautiously scale down pods by setting a stabilization window of 300 seconds to prevent rapid fluctuations in pod count.

Note: The **kkapp-deploy** deployment is created for backend; you can check in the terminal.

10. Deploy a Vertical Pod Autoscaler (VPA) with name **analytics-vpa** for the deployment named **analytics-deployment** in the default namespace.
The VPA should automatically adjust the CPU and memory requests of the pods to optimize resource utilization. Ensure that the VPA operates in Auto mode, allowing it to evict and recreate pods with updated resource requests as needed.

11.Create a Kubernetes Gateway resource with the following specifications:

- Name: **web-gateway**
- Namespace: **nginx-gateway**
- Gateway Class Name: **nginx**
- Listeners:
    - Protocol: **HTTP**
    - Port: **80**
    - Name: **http**

12. One co-worker deployed an nginx helm chart kk-mock1 in the kk-ns namespace on the cluster. A new update is pushed to the helm chart, and the team wants you to update the helm repository to fetch the new changes.


After updating the helm chart, upgrade the helm chart version to 18.1.15.












