# Mock Exam 1

You don't get what you wish for. You get what you work for.

â€“ Daniel Milstein

I am experienced enough to do this. I am knowledgeable enough to do this. I am prepared enough to do this. I am mature enough to do this. I am brave enough to do this.

1. Create a Pod **mc-pod** in the **mc-namespace** namespace with three containers. The first container should be named **mc-pod-1**, run the **nginx:1-alpine** image, and set an environment variable **NODE_NAME** to the node name. The second container should be named mc-pod-2, run the busybox:1 image, and continuously log the output of the date command to the file ``` /var/log/shared/date.log ``` every second. The third container should have the name mc-pod-3, run the image busybox:1, and print the contents of the date.log file generated by the second container to stdout. Use a shared, non-persistent volume.

2. This question needs to be solved on node node01. To access the node using SSH, use the credentials below:

```bash
username: bob
password: caleston123
```

As an administrator, you need to prepare node01 to install kubernetes. One of the steps is installing a container runtime. Install the **cri-docker_0.3.16.3-0.debian.deb** package located in /root and ensure that the **cri-docker** service is running and enabled to start on boot.

3. On controlplane node, identify all CRDs related to VerticalPodAutoscaler and save their names into the file /``` root/vpa-crds.txt ```.

4. Create a service **messaging-service** to expose the messaging application within the cluster on port 6379.

5. Create a deployment named hr-web-app using the image **kodekloud/webapp-color** with 2 replicas.

6. A new application orange is deployed. There is something wrong with it. Identify and fix the issue.

7. Expose the hr-web-app created in the previous task as a service named **hr-web-app-service**, accessible on port **30082** on the nodes of the cluster.

The web application listens on port **8080**.

8. Create a Persistent Volume with the given specification: -

- Volume name: pv-analytics
- Storage: 100Mi
- Access mode: ReadWriteMany
- Host path: /pv/data-analytics

9. Create a Horizontal Pod Autoscaler (HPA) with name **webapp-hpa** for the deployment named **kkapp-deploy** in the default namespace with the **webapp-hpa.yaml** file located under the root folder.
Ensure that the HPA scales the deployment based on CPU utilization, maintaining an average CPU usage of 50% across all pods.
Configure the HPA to cautiously scale down pods by setting a stabilization window of 300 seconds to prevent rapid fluctuations in pod count.

Note: The **kkapp-deploy** deployment is created for backend; you can check in the terminal.

10. Deploy a Vertical Pod Autoscaler (VPA) with name **analytics-vpa** for the deployment named **analytics-deployment** in the default namespace.
The VPA should automatically adjust the CPU and memory requests of the pods to optimize resource utilization. Ensure that the VPA operates in Auto mode, allowing it to evict and recreate pods with updated resource requests as needed.

11.Create a Kubernetes Gateway resource with the following specifications:

- Name: **web-gateway**
- Namespace: **nginx-gateway**
- Gateway Class Name: **nginx**
- Listeners:
    - Protocol: **HTTP**
    - Port: **80**
    - Name: **http**

12. One co-worker deployed an nginx helm chart kk-mock1 in the kk-ns namespace on the cluster. A new update is pushed to the helm chart, and the team wants you to update the helm repository to fetch the new changes.


After updating the helm chart, upgrade the helm chart version to 18.1.15.












